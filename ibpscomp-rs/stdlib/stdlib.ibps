""" ibps stdlib implemented in ibps """

from pprint import pformat

# Null value aliases
null=None
none=None

# Boolean aliases
true=True
false=False

# Output alias
output=print
print=None

# Type aliases
Boolean=bool
String=str
Integer=int
Float=float
Double=float
HashMap=dict

class Array(list):
    @classmethod
    sub __empty_array(CLS, *dimensions)
        if len(dimensions) < 1:
            return []
        if len(dimensions) == 1:
            return [None] * dimensions[0]
        return [CLS.__empty_array(*dimensions[1:]) for _ in range(dimensions[0])]
    end sub

    sub __init__(THIS, *dimensions)
        super().__init__(THIS.__empty_array(*dimensions))
    end sub

    sub push(THIS, VALUE)
        THIS.append(VALUE)
    end sub

    @classmethod
    sub fromValues(CLS, *VALUES)
        obj = CLS()
        for V in VALUES:
            obj.push(V)
        return obj

    @property
    sub length(THIS)
        return len(THIS)
    end sub

    sub __repr__(THIS)
        return pformat(super().copy())
    end sub

class Collection:

    sub __init__(THIS, *ARGS)
        THIS.INNER = list(ARGS)
        THIS.PTR = 0
    end sub

    sub isEmpty(THIS)
        return THIS.INNER == []
    end sub

    sub hasNext(THIS)
        return THIS.PTR < len(THIS.INNER)
    end sub

    sub getNext(THIS)
        if THIS.hasNext() then
            THIS.PTR += 1
            return THIS.INNER[THIS.PTR - 1]
        else
            raise StopIteration
        end if
    end sub

    sub addItem(THIS, ITEM)
        THIS.INNER.append(ITEM)
    end sub

    sub resetNext(THIS)
        THIS.PTR = 0
    end sub

    sub pop(THIS)
        return THIS.INNER.pop()
    end sub

    @property
    sub length(THIS)
        return len(THIS.INNER)
    end sub

    sub __repr__(THIS)
        return "Collection" + str(THIS.INNER)
    end sub

class Queue:

    sub __init__(THIS, *ARGS)
        THIS.INNER = []
        for ARG in ARGS:
            THIS.enqueue(ARG)
    end sub

    sub isEmpty(THIS)
        return THIS.INNER == []
    end sub

    sub __len__(THIS)
        return len(THIS.INNER)
    end sub

    sub enqueue(THIS, *ITEM)
        for I in ITEM:
            THIS.INNER.insert(0, I)
    end sub

    sub dequeue(THIS)
        return THIS.INNER.pop()
    end sub

    @property
    sub length(THIS)
        return len(THIS.INNER)
    end sub

    sub __repr__(THIS)
        return "Queue" + str(THIS.INNER)
    end sub

class __IBPSStackNode__:

    sub __init__(THIS, DATA)
        THIS.DATA = DATA
        THIS.NEXT = null
    end sub

class Stack:

    sub __init__(THIS, *ARGS)
        THIS.TOP = null
        THIS.push(*ARGS)
    end sub

    sub push(THIS, *ITEMS)
        for ITEM in ITEMS:
            NODE = __IBPSStackNode__(ITEM)
            if THIS.TOP is null
                THIS.TOP = NODE
            else
                NODE.NEXT = THIS.TOP
                THIS.TOP = NODE
            end if
        return ITEMS
    end sub

    sub pop(THIS)
        if THIS.TOP is null
            return null
        end if
        TEMP = THIS.TOP.DATA
        TEMP1 = THIS.TOP.NEXT
        THIS.TOP.NEXT = null
        THIS.TOP = TEMP1
        return TEMP
    end sub

    sub peek(THIS)
        return THIS.TOP.DATA
    end sub

    sub isEmpty(THIS)
        return THIS.TOP is null
    end sub

    sub list(THIS)
        CUR_NODE = THIS.TOP
        OUT = []
        loop while CUR_NODE is NOT null
            OUT.append(CUR_NODE.DATA)
            CUR_NODE = CUR_NODE.NEXT
        end loop
        return OUT
    end sub

    @property
    sub length(THIS)
        return len(THIS.list())
    end sub

    sub __repr__(THIS)
        return "Stack" + str(THIS.list())
    end sub

# end of stdlib
####
# compiled with ibps stdlib implemented in ibps